package day07_화;

/*

[ 메소드 ] 멤버함수 또는 메소드
	1. 정의 : 하나의 기능을 수행하는 일련의 코드
	2. 함수 정의/만들기
		반환타입 함수명( 타입 매개변수1, 타입 매개변수2 ){
			실행코드;
			return 반환값|반환값이 없으면 생략
		}
		1. 함수이름 :
			1. 변수명과 동일하게 임의
			2. 카멜표기법 권장
		2. 매개변수 : 함수의 입력으로 받는 변수
			1. 매개변수는 없을수도 있다.
			2. 함수 호출/사용시 인수값을 대입받는 변수
			3. 인수값의 타입과 매개변수 타입은 일치 해야한다.

		3. 반환값 : 함수를 수행한후 결과로 되돌려 주는 값
			1. return : 1.반환값 되돌려주는 역할 2. 함수 종료
			2. 반환값은 없을수도 있다. 반환타입 void
			3. 반환값의 타입 과 반환타입 은 일치 해야한다.

	3. 함수 호출
		 [1] 호출하고자 하는 함수가 같은 클래스에서 선언
		 	함수명();

		 [2] 호출하고자 하는 함수가 다른 클래스에서 선언
		 	* 객체 필요
		 	1. 클래스 변수명 = new 생성자();
		 	2. 변수.함수명();

 */

public class Example1_메소드  {

    public static void main(String[] args) {

        /*
         * =======================================================================
         * [ 파트 0. 왜 메소드(Method)가 필요할까요? - "객체는 행동한다!" ]
         * =======================================================================
         *
         * 클래스가 객체의 '속성(데이터)'을 정의한다면, 메소드는 객체의 '기능(행동)'을 정의합니다.
         * 메소드가 없다면 객체는 데이터를 담기만 하는 깡통에 불과합니다.
         *
         * [비유 1: 커피 머신]
         * - 속성(멤버변수) : 원두 종류, 물의 양, 우유 유무
         * - 기능(메소드)   : 전원켜기(), 에스프레소만들기(), 라떼만들기()
         *
         * 우리는 '라떼만들기()' 버튼만 누르면 됩니다. 복잡한 내부 동작은 알 필요가 없죠.
         * 이처럼 메소드는 복잡한 코드를 하나의 기능 단위로 묶어 재사용성을 높이고 코드를 간결하게 만듭니다.
         */

        System.out.println("--- [메소드 문법 마스터 클래스를 시작합니다!] ---");

        // --- 1. 객체 생성 및 메소드 호출 ---
        // 계산기(Calculator) 클래스로 실제 계산기 객체를 만듭니다.
        Calculator myCalc = new Calculator();

        // 1-1. 매개변수와 반환값이 없는 메소드 호출
        myCalc.powerOn(); // myCalc 객체의 powerOn() 기능을 실행

        // 1-2. 매개변수는 없고 반환값이 있는 메소드 호출 (추가된 예제)
        double piValue = myCalc.getPi();
        System.out.println("계산기에서 원주율 값 가져오기: " + piValue);

        // 1-3. 매개변수는 있고 반환값이 없는 메소드 호출
        myCalc.printSum(10, 20); // 10과 20을 전달하여 printSum() 기능을 실행

        // 1-4. 매개변수와 반환값이 모두 있는 메소드 호출
        // add(30, 50) 메소드가 실행되고, 그 결과(80)를 반환하여 result1 변수에 저장합니다.
        int result1 = myCalc.add(30, 50);
        System.out.println("add(30, 50)의 결과: " + result1);

        // 1-5. 메소드 오버로딩 확인
        // 같은 add 이름이지만, 실수를 전달했으므로 double을 처리하는 메소드가 자동으로 호출됩니다.
        double result2 = myCalc.add(3.14, 2.5);
        System.out.println("add(3.14, 2.5)의 결과: " + result2);


        // --- 2. 메소드 활용 예시 : 은행 계좌 관리 ---
        System.out.println("\n--- 2. 메소드 활용 예시 : 은행 계좌 ---");

        // BankAccount 클래스는 이 파일의 아래쪽에 정의되어 있습니다.
        BankAccount myAccount = new BankAccount();
        myAccount.owner = "유재석";
        myAccount.balance = 10000;

        System.out.println(myAccount.owner + "님의 초기 잔액: " + myAccount.checkBalance() + "원");

        // 입금(deposit) 메소드 호출
        myAccount.deposit(5000);
        System.out.println("5000원 입금 후 잔액: " + myAccount.checkBalance() + "원");

        // 출금(withdraw) 메소드 호출
        myAccount.withdraw(3000);
        System.out.println("3000원 출금 후 잔액: " + myAccount.checkBalance() + "원");

        // 잔액보다 큰 금액 출금 시도
        myAccount.withdraw(15000); // 출금 실패 메시지가 출력됩니다.
        System.out.println("잔액 초과 출금 시도 후 최종 잔액: " + myAccount.checkBalance() + "원");


        // ★★★ 결론: 메소드는 객체에 생명을 불어넣는 '행동'이며,
        // 복잡한 로직을 기능별로 캡슐화하여 코드의 가독성과 재사용성을 획기적으로 높여줍니다. ★★★
    }
}

